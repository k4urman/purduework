
Chapter 1
-----------------
example for helloworld.c

```c
#include <stdio.h>

int main()
{
	printf("Hello, World!\n");
	return 0;
}

```

breakdown of each line of code:

```c
#include <stdio.h>
```

This tells the compiler to include info about the standard *input/ouput (I/O)* library. This line appears at the beginning of many C source files. 

```c
int main(){
 //code here
}
```

This line defines a function *main* (like void main in Java) that receives no argument values. We can make the function void, other primitive type  (Make sure to return!), or simply leave it as main (this works like void). The statement is enclosed in braces like most code styles. 

```c
printf("Hello, World!\n");
```

main() calls library function (<stdio.h>) and grabs the function printf to print this sequence of characters. Just like in Java where we used System.out.print! We add the \n at the end of the expression to make a new line. The expression "Hello, World!\n" is called a *character string* or *string constant*. 

Now lets make a slightly more complex code program by making a program that will print Fahrenheit-Celsius equivalents. 

```c
#include <stdio.h>

/*
print Fahrenheit-Celsius table for fahr = 0, 20,...300
*/

main(){
	int fahr, celsius;
	int lower, upper, step;
	
	lower = 0; 
	upper = 300;
	step = 20;

	fahr = lower;
	
	while (fahr <= upper){
	
	celsuis = 5 * (fahr - 32) / 9;
	printf("%d\t%d\n", fahr, celsius);
	fahr = fahr + step;
	
	}
}

```

This looks quite a lot like a Java file! Just like in Java, the comments are made by the multi line use of the asterisk and the slash. These comments are always ignored by the compiler and are used to guide a programmer through the code and leave notes for themselves and others. 
In C, all variables need to be declared before they are used. It is normal to put them at the very top of the *main()* function before any logic. 
Just like in Java, int value Integers also exist. The length of the int or float (decimal numbers) depends on the device you are using. 16-bit ints which lie between -32768 and +32767 are common. A float is normally 32-bit quantity and between 10^-38 and 10^+38. Other data types include char, short, long, and double. 
The logic of the while loop is similar and does not need to be discussed heavily. The print statement does. %d like we've seen in Java is placement of a int inside of a String expression to be printed. the \t is used as a tab while the \n, as mentioned earlier, is used for newline. We can also add numbers for how big the %d can hold. Like %3d can hold up to 3 digits, while %6d holds 6 digits.

If one gets tired of first making defining the variables and then being able to put values in them, we can make them more defined via the (ironically named) define chaarecteristic. Observe.

```c
#include <stdio.h>

main(){

	#define LOWER 0
	#define UPPER 300
	#define STEP 20

	/*code below*/
}
```

They are now *symbolic constants*, not variables. They must be uppercase and notice how there is no semicolon afterwards. 

*Text stream* is a sequence of characters divided into lines, where each line consists of 0 or more characters followed by newline. The standard <stdio.h> has several functions for reading + writing one character at a such as *getchar* and *putchar*. 

```c

c = getchar();

putchar(c);

```

getchar contains the next character of input and stores it in the variable c. While, putchar prints the contents of the variable.

given *getchar* and *putchar*, you can write a suprising amount of useful code without anything more then I/O. Here's an example of I/O using one char at a time.

```c
#include <stdio.h>

/*copy input to output; Numero Uno version*/

main(){
	int c;
	c = getchar();
	
	while (c != EOF){
		putchar(c);
		c = getchar();
	}
}

```

```c
#include <stdio.h>

/*copy input to output; Numero Dos version*/

main(){
	double nc;

	for(nc = 0; getchar() != EOF; ++nc){
		printf("%.0f\n", nc);
	}
}
```

The meaning of the code. The code is meant to read a character. all while the character is not end-of-file (EOF acronym used above) indicator. Inside the while loop, it actively outputs the character just as read and reads the character. 

Now we will look at a program that counts input lines. 

```c
#include <stdio.h>
/* count lines in input */

main(){
	int c, nl;
	nl = 0;
	while ((c = getchar()) != EOF)
		if (c == '\n')
		++nl;
	printf("%d\n", nl);
}
```

As we mentioned above, the standard library ensures that an input text stream appears as a sequence of lines, each terminated by a newline. Hence, counting lines is just counting newlines.

The fourth in our series of useful programs counts lines, words, and characters, with the loose definition that a word is any sequence of characters that does not contain a blank, tab or newline.

```c
#include <stdio.h>

#define IN 1 /* inside a word */
#define OUT 0 /* outside a word */

/* count lines, words, and characters in input */

main(){

	int c, nl, nw, nc, state;
	state = OUT;
	nl = nw = nc = 0;
	
	while ((c = getchar()) != EOF) {
		++nc;
		if (c == '\n')
			++nl;
		if (c == ' ' || c == '\n' || c = '\t')
			state = OUT;
		else if (state == OUT) {
			state = IN;
			++nw;
		}
	}
	
	printf("%d %d %d\n", nl, nw, nc);
}
```

Every time the program encounters the first character of a word, it counts one more word. The variable state records whether the program is currently in a word or not; initially it is not in a word, which is assigned the value OUT.

Now, onto Arrays! Let us write a program to count the number of occurrences of each digit, of white space characters (blank, tab, newline), and of all other characters. There are twelve categories of input, so it is convenient to use an array to hold the number of occurrences of each digit, rather than ten individual variables.

```c
#include <stdio.h>

/* count digits, white space, others */

main(){

	int c, i, nwhite, nother;
	int ndigit[10];
	nwhite = nother = 0;

	for (i = 0; i < 10; ++i)
		ndigit[i] = 0;
	
	while ((c = getchar()) != EOF)
		if (c >= '0' && c <= '9')
			++ndigit[c-'0'];
		else if (c == ' ' || c == '\n' || c == '\t')
			++nwhite;
		else
			++nother;

	printf("digits =");

	for (i = 0; i < 10; ++i)
		printf(" %d", ndigit[i]);
	printf(", white space = %d, other = %d\n", nwhite, nother);
	
}
```

Now onto functions. Instead of redoing loops over and over again when needed later, we can create a seperate function that can reduce redundancy. It provides a convenient way to encapsute some computation, which can then be used without worrying  The following is an example of a to power (exponent) function:

```c
#include <stdio.h>

int power(int m, int n);

/*power function*/

int main(){
	int i;
	for(i = 0; i < 10; i++){
		printf("%d %d %d\n", i, power(2,i), power(-3,i));
	}
	return 0;
}

int power(int base, int n){
	int i, p;
	p = 1;
	for(i = 1; i <= n; i++){
		p = p * base;
	}
	return p;
}

```

A function format for C is the following:

```c
return-type function-name(parameter declarations, if any)
{
	declarations
	statements
}
```

it starts with the return type (char, float, normally int) and then the name of the function that can later be called later on. Just like in java, there are parameters you must push into the function but not always. Inside the brackets the logic will be applied. Make sure to always return something!

Looking at the power() function above, we can see the same logic. A int return type, the anme (being power()), and the parameters being the base and the n. 

Chapter 2 - TYPES, OPERATORS, + EXPRESSIONS
---------------------------------------------------------------------------------
Variables and connects are basic data storers in programming lanaguges that can be manipulated. The operators are what changes the variables (i.e. +, -, =...). 

Variable names are always lower case and connected via an underscore. Examples include g_secret, or temp_cel. The underscore counts as a letter, but do not start variables with it. 

There many different data types. Here are a few we will use in C:
- char - single btye, capable of holding 1 character in the local character set.
- int - an integer typically reflecting the natural size of integers on the host machine.
- float - single precision floating pt.
- double - double precision floating pt.

to use a variable we need to declare them prior. A declaration specifies a type, and contains a list of one or more variables (we will not do multiple). We can also assign it as it is declared.

```c
int lower, upper, step;
int i = 10;
```


Chapter 7 - Input + Output
------------------------------------------
Programs interact with their environment in much more complicated ways than those we have shown before. 

Such as in chapter 1, the libraries implements a simple model of text input and output. A text stream consists of a sequence of lines (all that end in a newline). If it does not, the system will do everything to make it that way, such as it might convert carriage return and linefeed to newline on input and back again in output. 

simple way of reading on character from standard input is via getchar.

```c
int getchar(void)
```

getchar returns the next input character each time it is called, or EOF end it encounters the end of the file. EOF (defined in <stdio.h> is valued at typically -1).

In many cases, a file may be substituted for the keyboard by using the < convention for input redirection.

```c
prog <infile
```

If the program prog uses get char, the above command line causes prog to read characters from infile instead. 

```c
otherprog | prog
```

the above command runs tow programs, otherprog and prog, and pipes the standard ouput of otherporg ito the standard input for prog. 

```c
int putchar(int)
```

the above command line used the output: putchar(c) puts the character c on the standard output, which is by default the screen. putchar returns the character written, or EOF if an error occurs. Again, output can usually be directed to a file with >filename: if prog uses putchar,

```c
prog >outfile
```

will write the standard output to outfile instead. If pipes are supported,

```c
prog | anotherprog
```

puts the standard output of prog into the standard input of anotherprog.

Let's see another program as an example called lower:

```c
/* lower: convert input to lower case */
#include <stdio.h>
#include <ctype.h>

main() 
{
	int c;

	while((c = getchar()) != EOF)
		putchar(tolower(c));
	return 0;
}
```

the function lower() is defined ctype.h which converts an uppercase to a lowercase and returns the characters untouched. 

The output function printf translates internal values to characters. We will look more deeply into it. 

```c
/* printf method */
int printf(char *format, arg1, arg2,...)
```

printf converts, formats, and prints its arguments on the standard output under control of the format. We can also include non-char values using the % sign. Between the % and the conversion character there may be, in order:
- a minus sign (-), which specifics the left adjustment of the converted argument
- A number that specifies the minimum field width. The converted argument will be printed in a field at least this wide. If necessary it will be padded on the left (or right, if left adjustment is called for) to make up the field width.
- A period, which separates the field width from the precision.
- A number, the precision, that specifies the maximum number of characters to be printed from a string, or the number of digits after the decimal point of a floating-point value, or the minimum number of digits for an integer.
- An h if the integer is to be printed as a short, or l (letter ell) if as a long

| Character | Argument type; Printed as                                                                                                                                                      |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| d, i      | int; decimal num                                                                                                                                                               |
| o         | int; unsigned octal num (w/ no leading 0)                                                                                                                                      |
| x, X      | int; unsigned hexadecimal num (w/ leader 0x or 0X), using abcdef or ABCDEF for 10,....,15                                                                                      |
| u         | int; unsigned decimal num                                                                                                                                                      |
| c         | int; single character                                                                                                                                                          |
| s         | char; print characters from the string until a '\0' or the number of characters given by the precision                                                                         |
| f         | double; [-]m.dddddd, where the number of d's is given by the precision (default 6)                                                                                             |
| e, E      | double; [-]m.dddddd e +-xx or [-]m.ddddddE+-xx, where the num of d's is given by the precision (default 6)                                                                     |
| g, G      | double; use %e or %E if the exponent is less than -4 or greater than or equal to the precision; otherwise use %f. Trailing zeros and a trailing decimal point are not printed. |
| p         | void; pointer (implementation-dependent representation).                                                                                                                       |
| %         | no argument is converted; print a %                                                                                                                                            |

```c
int printf(char *fmt, ...)
```

where the declaration ... means that the number and types of these arguments may vary. The declaration ... can only appear at the end of an argument list. 

```c
void minprintf(char *fmt, ...)

#include <stdarg.h>
/* minprintf: minimal printf with variable argument list */
void minprintf(char *fmt, ...)
{
	va_list ap; /* points to each unnamed arg in turn */
	char *p, *sval;
	int ival;
	double dval;
	va_start(ap, fmt); /* make ap point to 1st unnamed arg */

	for (p = fmt; *p; p++) {
		if (*p != '%') {
			putchar(*p);
			continue;
		}
		switch (*++p) {
		case 'd':
			ival = va_arg(ap, int);
			printf("%d", ival);
			break;
		case 'f':
			dval = va_arg(ap, double);
			printf("%f", dval);
			break;
		case 's':
			for (sval = va_arg(ap, char *); *sval; sval++)
				putchar(*sval);
			break;
		default:
			putchar(*p);
			break;
		}
	}
	
va_end(ap); /* clean up when done */
}
```


scanf is is the input analog of print, providing many of the same conversion facilities in the opposite direction.


Lecture 2
---------------
Topics: Compiling, Object Files, Linking and Execution

A short history of C: Created by Dennis Ritchie (1969-1973) at Bell Labs. Early OS typically implemented entirely in assembly language, so it was not portable. Ritchie had the desire to make it the UNIX OS portable

The Linux kernel is written in C (alongside Mac and Windows). Many libraries and programs are ran in C. Used for Embedded Systems, firmware, and drivers

Why C? Fast, powerful and simple (easy to do low-level things, fewer abstractions to worry about, and 32 keywords compared to other languages.) The language has continued to evolve (from version K&R or C78 and now the latest being C23). We will be using the C17 version in this class. Thus, the textbook which is running ANSI C, we have differences for out C 17 program. 

Main should always return an int, regardless of a the return type even though no error will show up. flout main() would turn to flout into a int. C like more machine languages, goes from C > compiler > to machine language.

to compile :
```c
gcc -o hello hello.c
./hello
```

the ./ stands for the current directory just like we did in lab. gcc? Stands for GNU Compiler Collection. Its a standard compiler for most UNIX-like OS systems.

**Helpful compile tips:**
- you can add -"VERSION OF C" -o hello hello.c
- c - compile file into object code (does not link)
- g - includes debug symbols
- Wall - enable (almost) all warnings
- Werror - turn warnings into errors
- OX - enable optimization level X (e.g., -01,-02..)
- o *file* - Output to 'file'
- ansi - adhere to the ANSI standard
- std=X - adhere to some standard X (e.g, C17, C32...)

What is an 'object' file? When you compile but do not link, you can create an object file. An object file is

Linking - making a executable from multiple objects files and libraries. Libraries are a special object file. Most programs are separated into multiple "modules" that are compiler individually and then linked together. Only ONE object file must contain main().


Lecture 3
-------------
function prototype - A forward declaration of a function which you have to declare before you use it

(#) symbol indicates a "preprocessor directive". extra steps before compilation begins. We'll cover this more later
- #include pulls a external file

```c
#include "file.h" // finds in current dir
#include <file.h> // finds in all system dir
```

whats the difference between .c and .h file? Header files describe a interface while C files describe an implementation. 

We refer to files with file pointers. A file MUST be opened prior before you can do something to it. 

```c
FILE * fopen(char *file_name, char *mode);
```

file_name - the path/name of the file
mode : are we reading, writing, visual

modes
- r: open the file and just read the file. The file must already exist
- w: creates a empty file we can write into. If a file already exists of the name it will be overwritten.
- a: appends to a prior created file. If file did not exit, it will be created, no overwriting

if successful, fopen() opens the file and returns a FILE pointer to represent the file. If not successful, fopen() returns NULL pointer. Always the FILE pointers will be opaque. Always check return value of fopen()!

fclose() 

```c
int fclose(FILE *file_pointer));
```

Every succesfuly opened file mist be closed when we are done with it. The internal file data is flushed one it is close. fclose() does not name file pointer NULL. Under success, it will return 0. on failure, returns EOF. You did not have check the value returned form fclose() in this close. 

Each program has access to special FILE pointers: stdin, stdout, stderr


Lecture 4
---------------
How does a C program represent text? With an array of char.
```c
char str[] = "abc";
```

You'll often see char * as a function argument type. This also refers to a string. Its technically a pointer but you can treat it as an array (Discussed later).

A valid C string ends with a special character called the NUL terminator. Its a char with the value 0, written like '\0' Its a "sentinel" value indicating the end of the string. String functions look for NUL to know when to stop (e.g., printf(), strlen(), etc.) The char array *must* have room for the NUL terminator.

A string literal refers rto double-quoted strings in code. String literals are already NUL terminated for you. You do not need to add the NUL terminator yourself. These are the same;

```c
char str[] = "abc"
char str[] = {'a', 'b', 'c', '\0'}
```

You can treat the string literals like arrays. But do not try to modify them, they are read-only

Many functions exist the maniuplate strings, and can include them all in #include<string.h> to use them. Most depend on NUL terminator.

STRLEN
```c
int strlen (char *str) // returns the # of char in the string, excluding NUL
int len = strlen("abc") // returns 3
/*If the string is not NUL terminated, strlen will read past the end of the array! */

```

STRCMP
```c
int strcmp(char *str1, char *str2); /*compares two strings. Returned negative value if str1 comes before str2, returns a positive value if str2 comes before str1, Returns 0 is same!*/

/*Order is determined by the encoding. Again relies in the strings to have NUL*/
```

STRCPY
```c
char *strcpy(char *dest, char *source); /*copies the source to the desination array. Also copies NUL. You must take care of the dest is large enough*/
```

Reading input = scanf
```c
int scanf(char *format,...);
```

reads chaarecters from stdin, interprets them according to the format. Stores reults in the locations given by the following arguments. format strings determines the number and type of the following arguments. ex:

```c
#include <stdio.h>

int main() {
	int x;
	scanf(“%d”, &x);

	printf(“%d\n”, x);
	return 0;
}
```

Formatting string: 
Whitespace character, read and skip any whitespace in the input stream. 
Non whitespace (except %), read next character in the input stream, compare to this character. If it matches, discard and continue, otherwise, abort.  
Conversion specifiers: starts with %, uses d,f,s,c, etc., and can also specify field width (max number of characters to read. )



Lecture 5
---------------
Homework 2 Hint
- **Issue in Code:**
  ```c
  in_fp = fopen(input, "r");
  if (in_fp == NULL) { return FILE_READ_ERR; }
  out_fp = fopen(output, "w");
  if (out_fp == NULL) { return FILE_WRITE_ERR; }
  ```
  - **Problem:** `in_fp` won’t be closed if `out_fp` fails to open!

Format Conversion Specifiers
- **Optional Fields:**
  - `[*]`: Read but do not store.
  - `[field_width]`: Limit number of characters read.
  - `[type_modifier]`: Specify type of receiving argument.
  
- **Format Types:**
  - `c`: character
  - `s`: string
  - `d`: decimal integer
  - `f`: float

 Field Width
- **Prevent Buffer Overflows:**
  ```c
  char str[16];
  scanf("%15s", str);
  ```
  - Reads up to 15 characters or until whitespace.
  - Remember to leave room for the NUL terminator!

Type Modifier
- **Example Usage:**
  ```c
  short x;
  long y;
  double z;
  scanf("%hd %ld %lf", &x, &y, &z);
  ```

Set of Characters
- **Specify Allowed Characters:**
  - Example: `%[ACGT]` matches any sequence of A, C, G, and T.
  - Ranges: `%[0-9]`, `%[A-Z]`, `%[0-9A-Za-z]`.
  - Inversion: `%[^0-9]`, `%[^\n]`.

scanf() Example
- **Input Matching:**
  ```c
  char str[16];
  int x;
  float y;
  scanf("%15s; %d; %f", str, &x, &y);
  ```
  - **Input:** `abc; 123; 4.56`
  - **Note:** `str` will include the `;` since `%15s` stops on whitespace.

Return Value of `scanf()`
- Returns the number of successful conversions.
- Check for errors by verifying if the return value is less than the number of variables to read.

End of File (EOF)
- If EOF is reached before reading anything, `scanf()` returns `EOF`.
- Use this to distinguish from an error.

EOF Example
```c
FILE *fp = fopen("xyz", "r");
while (1) {
    int x;
    char y[9];
    int z;
    int ret = fscanf(fp, "%d-%8[^-]-%d", &x, y, &z);
    if (ret == EOF) break;
    if (ret != 3) {
        fprintf(stderr, "Error!\n");
        break;
    }
    printf("%4d %8s %4d\n", x, y, z);
}
fclose(fp);
```

The `assert()` Macro
- Use `assert()` to make assertions in your code.
  ```c
  assert(non_neg_value >= 0);
  ```
- If the condition is false, the program aborts and shows where it occurred.

When to Use `assert()`
- **Do Use:**
  - To detect error conditions that cannot be handled.
  - To double-check expectations in your code.
  
- **Do Not Use:**
  - For conditions that can be handled otherwise.

assert() Example
```c
#include <assert.h> /* Must include this! */
#include <stdio.h>

int main() {
    int x = 1;
    printf("True assertion\n");
    assert(x == 1);
    printf("False assertion\n");
    assert(x == 12); // This will fail
    printf("End\n");
    return 0;
}
```

Turning Off `assert`
- Disable assertion checks at compile time:
```bash
gcc -DNDEBUG=TRUE -o my_prog my_prog.c
```
- All assertions will be skipped.

Using `assert` in Homework
- You will need to use assertion checks in future homeworks (not for hw2).
- Grading will include forcing assertions to fail.

Side Effects of Disabling `assert`
- If assertions are disabled, the code inside the assert will not execute.

Random File Access
- **File Pointer Operations:**
  - Get current position in the file (byte offset).
  - Go to the beginning, end, or an arbitrary position in the file.

`ftell()`
- Used to find the current position in the file.
- Returns:
  - Current byte offset from the beginning of the file.
  - `-1` in case of an error.
```c
int ftell(FILE *fp);
```

`fseek()`
- Used to move to a specific position in the file.
- Returns `0` if successful or `-1` if an error occurs.
```c
int fseek(FILE *fp, long offset, int whence);
```

`fseek()` Whence Options
- `SEEK_SET`: Offset is relative to the beginning of the file.
- `SEEK_CUR`: Offset is relative to the current position.
- `SEEK_END`: Offset is relative to the end of the file.

Examples of `fseek()`
- Move to the beginning of the file:
```c
fseek(fp, 0, SEEK_SET);
```
- Move to the end of the file:
```c
fseek(fp, 0, SEEK_END);
```
- Move backwards fourteen bytes:
```c
fseek(fp, -14, SEEK_CUR);
```
- Move to the 28th byte in the file:
```c
fseek(fp, 28, SEEK_SET);
```
- Move to 12 bytes before the end:
```c
fseek(fp, -12, SEEK_END);
```

Tricks with File Access
- **Find out how long a file is:**
```c
fseek(fp, 0, SEEK_END);
int len = ftell(fp);
fseek(fp, 0, SEEK_SET);
```
- **Check for EOF:**
```c
fscanf(fp, "%s", buffer);
if (ftell(fp) == len) { ... }
```

Lecture 6
---------------
**Announcements**
- Homework 3 is out now!
- Homework 2 is due on Wednesday.

**File Handling in C**
**fseek() and ftell()**
- **Purpose**: Used to navigate and determine the current position in an open file.
  
**Examples of fseek()**
- Move to the beginning of the file:
  ```c
  fseek(fp, 0, SEEK_SET);
  ```
- Move to the end of the file:
  ```c
  fseek(fp, 0, SEEK_END);
  ```
- Move backwards fourteen bytes:
  ```c
  fseek(fp, -14, SEEK_CUR);
  ```
- Move to the 28th byte in the file:
  ```c
  fseek(fp, 28, SEEK_SET);
  ```
- Move to 12 bytes before the end:
  ```c
  fseek(fp, -12, SEEK_END);
  ```

**Important Note**
- Reading and writing operations change the current position in the file.
  ```c
  FILE *fp = fopen("file", "r");
  int pos = ftell(fp); // returns 0
  int x;
  fscanf(fp, "%d", &x);
  pos = ftell(fp); // returns > 0
  ```

**Uses for Random File Access**
- Accessing a file as a database.
- Extracting parts of a file.
- Modifying specific bytes in the file without rewriting the entire file.
  - Note: Only works on byte ranges, not lines.

**Takehome Quiz #1**
- **Task**: Write a function named `print_chars()` that:
  - Opens a file for reading with the name specified by the argument.
  - Returns `ERR_ON_OPEN` if the file cannot be opened.
  - Uses `fscanf()` to read exactly 50 characters into an array.
  - Returns `ERR_ON_READ` if 50 characters cannot be read.
  - Outputs every non-whitespace character in reverse order.
  - Closes the file and returns `OK`.

**Quiz Reminder**
- Due in 24 hours.
- Handwritten answers only.
- Limit submission to one page (double-sided).
- Quiz template is optional.

**typedef in C**
**Overview**
- Standard C has built-in types (e.g., int, char, float).
- You can create your own types using `typedef`.

**When to Use typedef**
- When a variable type is frequently used and has a long description.
- When you might change a parameter type later.
- When defining structures.

**Getting the Syntax Right**
- Pretend you’re defining a variable of the type you want to see.
- Add `typedef` to the beginning of the definition.

**Examples**
```c
typedef int my_number;
typedef double my_array[3];
my_number n = 5;
my_array arr = {1.5, 2.9, 3.7};
```

**Introduction to Structures**
- Structures help group multiple pieces of data together.
- A structure allows you to use one name to refer to many variables.

**Structure Declaration Example**
```c
struct my_data {
    int age;
    float height;
};
```

**Accessing Elements**
- Use the dot (.) operator to access internal elements.
```c
my_var.height = 6.1;
int x = my_var.age;
printf("Age: %d, Height: %f\n", my_var.age, my_var.height);
```

**Properties of Structures**
- Structures can contain arrays and other structures.
- Structures can be passed to and returned from functions.

**Struct Typedef Example**
```c
typedef struct my_data {
    int age;
    float height;
} my_data_t;
```

**Definitions vs. Declarations**
- **Definition**: Allocates storage for a variable or function.
- **Declaration**: Announces the properties of a variable or function.

**Example of Struct Declaration**
```c
struct hey {
    int zap;
    float zing;
};
```

**Structures Inside Structures**
- You can define structure variables inside other structures.

**Example**
```c
struct segment {
    struct coord one;
    struct coord two;
};
```

**Arrays in Structures**
- You can define array variables in structure declarations.

**Example**
```c
struct location {
    char name[40];
    float coords[3];
};
```

**For Next Lecture**
- Study and practice the examples.
- Finish homework 2.
- Start homework 3.

Lecture 7
--------------
**CS 240: Programming in C - Lecture 7: Arrays, Memory Layout of Data**

**Announcements**
- Homework 1 style grades released
  - Check your score on Gradescope
  - Scoring out of 20 points; actual grade calculated as:
    - `grade = max(20 + score, 0)`
    - Example: Gradescope score of -8 results in a grade of 12/20
    - Example: Gradescope score of -22 results in a grade of 0/20
- Use feedback for Homework 2
  - Resubmit before the deadline (9:00 PM tonight) without penalty

**Homework Testing**
- Ensure you are testing your homeworks!
  - Compile and link with the test module: `$ make`
  - Run the test module: `$ ./hw2_test`
  - This runs the same tests used for grading
  - Run it multiple times (some tests are random)
  - Turn in when finished: `$ make submit`

**Arrays of Structures**
- Create arrays of structs like any other array
  - Example: `struct location places[3];`
- Initialization example:
  ```c
  struct location places[3] = {
      { "Indianapolis", {39.7691, 86.1580, 219.151} },
      { "West Lafayette", {40.4259, 86.9081, 187.147} },
      { "Chicago", {41.8781, 87.6298, 181.966} },
  };
  ```

**Arrays of Structures Example**
- Code example:
  ```c
  #include <stdio.h>
  #include <string.h>
  #define MAX_PLACES (200)
  #define MAX_NAME_LEN (40)

  struct location {
      char name[MAX_NAME_LEN];
      float coords[3];
  };

  struct location places[MAX_PLACES]; // global!
  ```

**Print Location Function**
- Function to print location:
  ```c
  void print_location(struct location loc) {
      printf("%s (%0.4f, %0.4f, %0.3f)\n", loc.name, loc.coords[0], loc.coords[1], loc.coords[2]);
  }
  ```

**Main Function Example**
- Example of main function:
  ```c
  int main() {
      strncpy(places[0].name, "Indianapolis", MAX_NAME_LEN);
      places[0].coords[0] = 39.7691;
      places[0].coords[1] = 86.1580;
      places[0].coords[2] = 219.151;
      places[1] = (struct location) { "West Lafayette", { 40.4259, 86.9081, 187.147 } };
      
      for (int idx = 0; idx < MAX_PLACES; idx++) {
          if (places[idx].name[0] != '\0') {
              print_location(places[idx]);
          }
      }
      return 0;
  }
  ```

**Notes About Previous Example**
- Global variables are automatically initialized to 0 if not explicitly set
- Only the first two elements of the array were assigned values; the rest are 0
- Validity check for array elements: `if (places[idx].name[0] != '\0')`

**Array Initialization**
- Partial initialization of arrays is allowed:
  ```c
  int primes[200] = { 2, 3, 5, 7, 11, 13 };
  ```
- Remaining elements are set to 0 (for both global and local arrays)

**Array Auto-Sizing**
- Define and initialize an array without specifying size:
  ```c
  int fib[] = { 1, 1, 2, 3, 5, 8, 13 }; // size 7
  char message[] = "auto-size"; // size 10 (NUL terminator included)
  ```

**Variable Length Arrays**
- Size of an array can be a variable:
  ```c
  int x;
  scanf("%d", &x);
  int numbers[x]; // Not recommended
  ```
- Reasons to avoid:
  - Bug-prone
  - Unpredictable size in function context
  - Potential memory issues
  - Forbidden by code standard: XII-D

**Data Layout in Memory**
- Memory is a continuous stream of bytes
- Variables occupy one or more bytes of memory
- Example: `int my_var = 0;` occupies 4 bytes

**Variables**
- Compiler allocates memory for variables
- Variables defined near each other are usually close in memory
- Compiler may change order of variable placement

**Arrays**
- Arrays are guaranteed to be packed together in memory:
  ```c
  int array[3] = { 0x11111111, 0x22222222, 0x33333333 };
  ```

**Strings**
- Strings in C are arrays of characters, NUL-terminated
- Functions like `strcpy()`, `strcmp()` search for the NUL

**Two Dimensional Arrays**
- 2-D arrays are stored in memory in a contiguous block:
  ```c
  char array2d[2][3] = { {1, 2, 3}, {4, 5, 6} };
  ```

**Structures**
- Structure members are packed together in memory
- Example structure:
  ```c
  struct my_stuff {
      int i; // 4 bytes
      float f; // 4 bytes
      char c[6]; // 6 bytes
  } my_var = { 0, 0, "Hi" };
  ```

**Variable Sizes and Types**
- Size of variables may differ across machines and compilers
- Example: `long` is 4 bytes on x86, 8 bytes on x86_64

**sizeof() Operator**
- `sizeof()` can determine the size of any variable or type:
  ```c
  int array[100];
  printf("Size of char = %d\n", sizeof(char));
  printf("Size of array = %d\n", sizeof(array));
  ```

**Structure Alignment**
- Primitive datatypes must be aligned for efficient access
- Example:
  ```c
  int my_int;
  assert(&my_int % 4 == 0);
  ```

**Alignment Within Structures**
- Structure members must be aligned:
  ```c
  struct thing {
      short s; // 2 bytes
      int i; // 4 bytes
  };
  ```

**Padding in Structures**
- Structures may have padding for alignment:
  ```c
  struct strange {
      int x; // 4 bytes
      int y; // 4 bytes
      int z; // 4 bytes
      char c; // 1 byte
  };
  ```

**Arrays of Structures**
- Arrays of structures are packed together in memory
- Trailing padding ensures proper alignment in arrays

**How Much Trailing Padding?**
- Padding ensures the size of the struct is a multiple of the size of its largest member

**Creating Inefficient Structs**
- Example of inefficient struct:
  ```c
  struct bad {
      char c1;
      int i1;
      char c2;
      int i2;
      char c3;
      int i3;
      char c4;
  };
  ```

**Creating Efficient Structs**
- Reorder variables to reduce padding:
  ```c
  struct not_so_bad {
      int i1;
      int i2;
      int i3;
      char c1;
      char c2;
      char c3;
      char c4;
  };
  ```

**Structure Alignment Rule of Thumb**
- Order fields by size from largest to smallest to minimize padding

**Takehome Quiz #2**
- Determine the size of a given struct
- Draw a memory diagram labeling each byte and padding
- Rewrite the struct to minimize size and draw a second memory diagram

**For Next Lecture**
- Read K&R sections: 2.3, 4.4, 6.8-6.9, A8.3-A8.4
- Practice the examples!



Lecture 8
----------------

**Announcements**
- **Homework 2 has been graded**
  - There are still some issues; the assignment will be regraded.
  - Two things that caused point deductions:
    - Using forbidden functions
    - Buffer overflows
- **Takehome Quiz #1 has been graded**
  - See your score on Gradescope.
  - Regrade requests are open for one week.
- **Homework 4 will be released today.**

**Binary File I/O**
- Given an open FILE pointer, we can use `fread()` and `fwrite()` to read or write “raw” memory items to or from a file.
  - `fwrite(void *ptr, int size, int num, FILE *fp);`
  - `fread(void *ptr, int size, int num, FILE *fp);`
- This allows you to “dump” a data structure directly into a binary format file.

**fread() Example**
```c
#include <stdio.h>
struct xy { int x; int y; };
int main() {
    struct xy try = { -1, -1 };
    FILE *fp = fopen("xy.file", "rb");
    int ret = fread(&try, sizeof(struct xy), 1, fp);
    printf("Read values (%d, %d) with return %d\n", try.x, try.y, ret);
    fclose(fp);
    return 0;
}
```

**Return Values**
- Both `fread()` and `fwrite()` return the number of items that were read or written.
- On error, they return a short item count (or zero).

**Uses of fread()**
- Recall the prototype:
  - `fread(void *ptr, int size, int num, FILE *fp);`
- The “void *” means we can pass a pointer to “anything”.
- Considerations:
  - What value should this call to `fread()` return?
  - How many bytes are read by this operation?
  - How would we read a whole file full of the structures?
  - Is there any data format checking with this?

**fwrite() Example**
```c
#include <stdio.h>
struct xy { int x; int y; };
int main() {
    struct xy try = { 1, 2 };
    FILE *fp = fopen("xy.file", "wb");
    int ret = fwrite(&try, sizeof(struct xy), 1, fp);
    printf("ret: %d\n", ret);
    fclose(fp);
    return 0;
}
```

**fwrite() Multiple Structs**
```c
int main() {
    struct xy xys[20];
    for (int i = 0; i < 20; i++) {
        xys[i].x = i + 1;
        xys[i].y = -(i + 1);
    }
    FILE *fp = fopen("xys.file", "wb");
    int ret = fwrite(xys, sizeof(struct xy), 20, fp);
    printf("ret: %d\n", ret);
    fclose(fp);
}
```

**fwrite()ing Multiple Structs**
- Example output:
  ```
  $ gcc fwrite_mult.c
  $ ./a.out
  ret: 20
  $ cat xys.file
  ```

**fwrite()ing Multiple Structs - Hexdump**
```
$ hexdump -C xys.file
00000000   01 00 00 00 ff ff ff ff 02 00 00 00 fe ff ff ff   |................|
...
```

**Summary of fread()/fwrite()**
- Moves a “memory image” to or from a file.
- The file is not portable.
- Different systems have different formats for integers, floats, etc. (Endianness).
- No data type checking.

**Endianness**
- Endianness is the order of bytes in a word or multi-byte value.
  - Two schemes:
    - Big-endian: most significant byte first (lowest address).
    - Little-endian: least significant byte first.

**Example of Endianness**
- Consider the integer value 305419896 (0x12345678).
- In memory:
  - Big-endian: 12 34 56 78
  - Little-endian: 78 56 34 12

**Union**
- Similar to structs, but internal elements overlap.
```c
union my_union { int i; float f; char c; } my_var;
```

**Union Example**
```c
union my_union my_var;
my_var.i = 86593;
printf("%c\n", my_var.c);
```

**Initialization of Union**
```c
union my_union { int i; float f; };
union my_union my_var = { 5 }; // Initializes the first field.
```

**Why Unions?**
- When you really need to save space in your program and you know that some data will be one of two types.
- Deep operating system hacking, peripheral I/O manipulation, format conversion.

**Enum**
- Attaches labels to values.
```c
enum color { RED, GREEN, BLUE };
enum color my_hue = GREEN;
```

**Enum Example**
```c
#include <stdio.h>
enum color { RED, GREEN, BLUE };
int main() {
    enum color my_hue = GREEN;
    switch (my_hue) {
        case RED:
        case GREEN:
            printf("Red or Green.\n");
            break;
        case BLUE:
            printf("Blue.\n");
            break;
    }
    return 0;
}
```

**Enums Can Also Have Values**
```c
enum transport { LAND=1, SEA=2, AIR=3, SUBMARINE=2, FLYING_SAUCER=400 };
```

**Use of Enum Example**
```c
#include <stdio.h>
int main() {
    enum transport craft = AIR;
    printf("Value of craft is %d\n", craft);
    return 0;
}
```



Lesson 17
--------
global variables: variables accesble in all functions
local variables: visable only in one function

```c
void countdown(int n) {
  if (n >= 0) {
    printf(“%d\n”, n);
    countdown(n-1);
  }
  return;
}

int main() {
  countdown(10);
  return 0;
}
```

Recursion: When you write a function that invokes iteself, the practice is called recursion. For many computation, there is a way to write it recursiivly and itertivly

```c
countdown(n=2):
  if (n >= 0) {
  printf(“%d\n”, n);
  countdown(n-1);
}
return;
```

Each time you invoke a function, the invocation of the function takes some space on the stack for parameters, local car. and an indication about where to return to. This is called stack trace!
When a function returns, its reservation of the stack for local var. goes away. 

```c
void countup(int n) {
  if (n >= 0) {
    countup(n-1);
    printf(“%d\n”, n);
  }
  return;
}

int main() {
  countup(10);
  return 0;
}
```

examples:

```c
int factorial(int n) {
  if (n == 0) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

```c
int fibonacci(int n) {
  if (n == 0)
    return 1;
  if (n == 1)
    return 1;
  return (fibonacci(n - 1) + fibonacci(n - 2));
}
```

you always need to tell the function when to stop invoking itself (Called based case) (n=1, return 1, n=0, return 1, example above^)
Don’t return a pointer to something on the stack and don’t recurse too deeply

Up until now, we've looked at lists that have one "dimension" (foward/backward, prev)
Consider a structure that acts as a "parent" and has at most two "children" a binary three

```c
struct node {
  int value;
  struct node *left;
  struct node *right;
};
```

**Interesting properties of trees:**
- We hold one pointer to the "root" of tree
- Nodes w/o children is "leaf" node
- nodes w/ 1 or 2 nodes is called "internal nodes"
- The "height" of tree is # of nodes on the longest path from root to a leaf
- Each node stores a value
- Every internal node is also the root of a "subtree"

**Binary search trees**
- Its often convient to enfore an order on the values in the nodes
- For **any** node w/ value v:
	- All nodes in the left subtree always have values less than or equal to v
	- All nodes in the right subtree always have values greater than v
- We call such an ordered tree Binary Search Tree (BST)
- BST ⊂ Binary Tree: Every BST is a Binary Tree, but not every Binary Tree is a BST
- A general binary tree does not require an order of the nodes But we’ll mostly discuss BSTs in this class
- A BST is always fully sorted and is easily searchable

examples:

```c
/*BST functiosn (create)*/
struct node *create_node(int value) {
  struct node *ptr = NULL;
  
  ptr = malloc(sizeof(struct node));
  assert(ptr != NULL);
  
  ptr->left = NULL;
  ptr->right = NULL;
  ptr->value = value;
  return ptr;
}
```

```c
/*BST functions (insert, iterative)*/
void insert_node(struct node *curr, struct node *new) { 
while (1) {
    if (new->value <= curr->value) {
      if (curr->left == NULL) {
        curr->left = new;
        return;
      } else {
        curr = curr->left;
      }
    } else {
      if (curr->right == NULL) {
        curr->right = new;
        return;
    } else {
      curr = curr->right;
    }
 . }
  }
}
```

```c
/*BST Functions (insert, recursive)*/
void insert_node(struct node *curr, struct node *new) {
  if (new->value <= curr->value) {
    if (curr->left == NULL) {
      curr->left = new;
      return;
    } else {
      insert_node(curr->left, new);
    }
  } else {
    if (curr->right == NULL) {
      curr->right = new;
      return;
    } else {
      insert_node(curr->right, new);
    }
  }
}

```

**Searching a BST** is just as easy as inserting:
1. Set the current node pointer to point to the root
2. If the value we’re looking for == the current node’s value
	-  Return the current node
3. If the search value < the current node’s value, go left
	-  i.e., curr = curr->left;
4. Otherwise, go right
5. Repeat from step 2
6. If the pointer is ever NULL, return NULL to indicate the value was not found

```c
void insert_node(struct node *curr, struct node *new) {
if (new->value <= curr->valuestruct node *bst_find(struct node *curr, int value) {
    if (curr == NULL) return NULL;         /* Not found */
    if (value == curr->value) return curr; /* Found it */
    if (value < curr->value)               /* Go left */
      return bst_find(curr->left, value);
    /* Go right */
    return bst_find(curr->right, value);
}
```

**How do we access the sorted values?**
- We know that a BST is fully sorted
	- The “least” element in the tree is at the far left
	- The “greatest” element in the tree is at the far right
- What if we want to list the elements in the tree?
- Our tree nodes do not point back to their parents
	- How can we start at the far left and go through each node in order?

**Tree traversal**
- Accessing each of the nodes of a tree in order is called a tree traversal. We can do this in several ways:
	- Least to greatest: for each node, access the left node recursively, then the node itself, then the right node recursively L-N-R
	- Greatest to least: same way, but reversed: R-N-L
	- Prefix: N-L-R
	- Postfix: L-R-N
- Changing the order of the recursive calls gives us a different printout order


Lesson 18
-----------------
- Dynamic arrays” == heap-allocated
- We can only use dynamic arrays if we know the amount of memory needed before allocation
- BUT, we don’t need to know it at compile-time
	- If we know at compile-time, we can allocate on the stack provided it’s not too large
- If we can’t know the size before creation, we must use linked lists or another dynamic data structure![[Screenshot 2025-03-26 at 10-46-59 CS 240 S25 LEC 18 - LEC-18.pdf.png]]

- recall that 2D arrays are contagous in memory
- we ca gthink of them as 1d arrays
- simply allocate (rows x cols) elements via:

```c
int *arr = calloc(rows *cols, sizeof(int));
assert(arr);
```

![[Screenshot 2025-03-26 at 10-51-30 CS 240 S25 LEC 18 - LEC-18.pdf.png]]

- access is only truly valid if 0 <= 1 < rows and 0 <= j < cols
- What happens outside of range?: rows =3, cols = 4, i=1, j=6 -> 
```c
*(arr + cols * i + j)
```

We can also make 3d arrays:

```c
int *arr = calloc (width * height * depth , sizeof(int));
assert(arr);

/*to index:*/

int x, y, z;
arr[width * height * z + width * y + x]
```

- Assumes the order of dimensions in memory is Z,Y,X
	- x is the “most frequently changing coordinate”
	- z is the “least frequently changing coordinate”
- The order is ultimately up to us to decide

other ways to make 2d arrays are:

```c
int **arr = calloc(rows, sizeof(int *));
assert(arr);

for (int i = 0; i < rows; i++) {
  arr[i] = calloc(cols, sizeof(int));
  assert(arr[i]);
}

arr[i][j]
```

- We can give each row a different number of columns!
- Sometimes this is called a “jagged” array
	- NOT a 2D array; 2D arrays are always rectangular
- Allocation and deallocation is more complicated
- Rows are not adjacent, can be inefficient

```c
for (int i = 0; i < rows; i++) {
  arr[i] = calloc(i * 4, sizeof(int));
  assert(arr[i]);
}
```

![[Screenshot 2025-03-26 at 11-08-17 CS 240 S25 LEC 18 - LEC-18.pdf 1.png]]

- There are general rules-of-thumb for the size of a variable, depending on size
	- the only way to make sure is to use sizeof()
- there are rules that say for instance that an int mist be no smaller than a short and no larger than a long
- types are automatically promoted to the next larger type of the family (e.g. integer or floating-point) within arithmetic operations

- After promotion, arguments to an operator are checked
	- If the same, proceed
	- Otherwise, conversions may take place
	- For each type, if one of the arguments is that type, the other is converted to the same type, in order:
		- long double, double, float, unsigned long, long, unsigned, int


- integer types (char, short, int, long, long long) can have an additional modifier to indicate to the compiler whether the datum represents a signed or unsigned (always non-negative) value.
```c
unsigned char x = 200; /* OK */
signed char y = 200; /* overflow */
```

- For non-integer types, “signed” has no meaning
- The default modifier for int is signed
- What’s the default modifier for char?

- Constructed types are second-class types. They are created by the programmer.
- Examples of second-class types include anything that the programmer declares that is a struct, union, enum, or pointer to anything

![[Screenshot 2025-03-26 at 11-16-48 CS 240 S25 LEC 18 - LEC-18.pdf.png]]








# Lecture 22: Random Numbers, APIs, Graphics

## Random Numbers

### Overview
- Computers cannot generate **truly random** numbers due to their deterministic nature.
- **Truly random** implies numbers with no predictable pattern, which is philosophically complex.
- Instead, computers generate **pseudo-random** sequences that mimic randomness but are deterministic given a starting point (seed).

### Basic Pseudo-Random Numbers
- The C standard library provides the `random()` function to generate pseudo-random numbers.
- Example code to generate 10 numbers between 0 and 99:
  ```c
  #include <stdlib.h>
  #include <stdio.h>
  int main() {
      for (int i = 0; i < 10; i++) {
          printf("A random number: %d\n", random() % 100);
      }
  }
  ```
- **Issue**: Without setting a seed, this code produces the **same sequence** every time the program runs, which is not ideal for most applications.

### Improving Pseudo-Randomness with Seeds
- To generate different sequences each run, use a **seed** to initialize the random number generator.
- The `srandom()` function sets the seed, often using the current time (`time(0)`) for variability.
- Example with seed:
  ```c
  #include <stdlib.h>
  #include <stdio.h>
  #include <time.h>
  int main() {
      srandom(time(0));
      for (int i = 0; i < 10; i++) {
          printf("A random number: %d\n", random() % 100);
      }
  }
  ```
- **Key Points**:
  - Same seed → same sequence (useful for reproducibility, e.g., debugging or simulations).
  - Different seeds → different sequences.
  - Using `time(0)` ensures a new seed each run, as the time changes.

### Random Seeds and Reproducibility
- Seeds are critical for controlling randomness:
  - **Reproducibility**: Save the seed to replay the same sequence (e.g., for testing or scientific experiments).
  - **Uniqueness**: Use a varying seed (like time) for unique sequences.
- However, `random()` and `srandom()` are **not cryptographically secure**:
  - If the seed is known or guessed, the sequence can be predicted.
  - Unsuitable for applications like cryptography where security is paramount.

### Cryptographically Secure Randomness
- For security-sensitive applications (e.g., encryption), use a **cryptographically secure random number generator**.
- **`/dev/urandom`**:
  - A Linux/Unix device file that provides a stream of random bytes.
  - Sourced from **entropy** (unpredictable system events).
  - Example code:
    ```c
    #include <stdlib.h>
    #include <stdio.h>
    int main() {
        FILE *rng = fopen("/dev/urandom", "rb");
        for (int i = 0; i < 10; i++) {
            unsigned int r;
            fread(&r, sizeof(int), 1, rng);
            printf("A random number: %d\n", r % 100);
        }
        fclose(rng);
        rng = NULL;
    }
    ```
  - **How it works**:
    - Opens `/dev/urandom` in binary read mode (`"rb"`).
    - Reads random bytes into an integer variable.
    - Closes the file to free resources.
- **Entropy Sources** for `/dev/urandom`:
  - Keyboard timings.
  - Mouse movements.
  - Network latency.
  - Audio/video input.
  - Thermal noise.
  - These unpredictable events ensure high-quality randomness.

### Random Distributions
- `random()` and `/dev/urandom` produce **uniformly distributed** numbers (each value equally likely).
- Other distributions are often needed for modeling real-world phenomena:
  - **Bernoulli**: Models binary outcomes (e.g., coin flip).
  - **Normal (Gaussian)**: Bell curve, common in natural phenomena.
  - **Binomial**: Number of successes in repeated trials.
  - **Geometric**: Number of trials until first success.
  - **Poisson**: Number of events in a fixed interval.
- **Transformation**: Equations exist to convert uniform distributions into other distributions (e.g., Box-Muller for Normal).

---

## APIs (Application Programming Interfaces)

### Overview
- Most programming tasks (95%) don’t require complex data structures or algorithms.
- Instead, they involve learning and using **APIs**:
  - APIs define how to interact with existing libraries or systems.
  - Example: Graphics programming relies heavily on APIs like SDL, OpenGL, or Vulkan.
- **Key Skill**: Understanding API documentation and integrating it into your code.

### Simple DirectMedia Layer (SDL)
- **What is SDL?**
  - A cross-platform library for low-level access to:
    - Audio.
    - Keyboard.
    - Mouse.
    - Graphics.
  - Widely used in:
    - Major games: Source Engine (Portal 2, Left 4 Dead 2, Counter-Strike, Team Fortress 2).
    - Indie games: Factorio, Dwarf Fortress, Amnesia.
    - Emulators: DosBox, ZSNES.
- **Why SDL?**
  - Simplifies hardware interaction.
  - Abstracts platform-specific details (Windows, Linux, macOS).

### Structure of an SDL Application
1. **Initialization**:
   - Set up SDL subsystems (e.g., video, events).
   - Create a window.
2. **Main Loop**:
   - Read input (keyboard, mouse).
   - Process events (e.g., window close).
   - Update program state.
   - Draw to the screen.
3. **Cleanup**:
   - Free resources (e.g., destroy window).
   - Shut down SDL.

---

## SDL Programming Details

### Initialization
- **`SDL_Init(Uint32 flags)`**:
  - Initializes SDL subsystems (e.g., video, events).
  - Must be called before other SDL functions.
  - Example flags: `SDL_INIT_VIDEO`, `SDL_INIT_EVENTS`.
  - Returns `false` on failure.
- **`SDL_CreateWindow(const char *title, int w, int h, Uint64 flags)`**:
  - Creates a window with specified title, width, height, and flags.
  - Returns a pointer to an `SDL_Window` or `NULL` on failure.

### Cleanup
- **`SDL_DestroyWindow(SDL_Window *window)`**:
  - Frees memory associated with the window.
- **`SDL_Quit()`**:
  - Shuts down all SDL subsystems.
  - Call before program exit.
- **Order Matters**:
  - Clean up resources in **reverse order** of initialization to avoid memory leaks.

### Events
- SDL generates **events** for user actions or system changes:
  - Keyboard/mouse input.
  - Window resizing/closing.
  - Audio device changes.
  - Custom events.
- **Event Queue**:
  - Events are stored in a queue.
  - Process them to keep the application responsive.
- **`SDL_PollEvent(SDL_Event *event)`**:
  - Checks for events in the queue.
  - If an event exists, removes it and stores it in the provided `SDL_Event`.
  - Returns `true` if an event was retrieved, `false` if queue is empty.
- **Checking Event Type**:
  - Query `event.type` to identify the event.
  - Example: Check for key press:
    ```c
    if (event.type == SDL_EVENT_KEY_DOWN) {
        // Handle key press
    }
    ```
  - Check specific key:
    ```c
    if (event.key.key == SDLK_ESCAPE) {
        // Handle ESC key
    }
    ```

### Drawing to the Screen
- **Surface**:
  - A region of graphical memory mapped to the window.
  - Obtained via:
    ```c
    SDL_Surface *SDL_GetWindowSurface(SDL_Window *window);
    ```
  - `SDL_Surface` structure:
    ```c
    struct SDL_Surface {
        Uint32 flags;
        Uint32 format;  // Pixel format
        int w;          // Width in pixels
        int h;          // Height in pixels
        int pitch;      // Bytes between rows
        void *pixels;   // Pointer to pixel data
    };
    ```
- **Locking/Unlocking**:
  - Surfaces must be locked before modifying pixels:
    ```c
    bool SDL_LockSurface(SDL_Surface *surface);
    ```
  - Unlock after modification:
    ```c
    void SDL_UnlockSurface(SDL_Surface *surface);
    ```
- **Updating Display**:
  - After drawing, update the window to show changes:
    ```c
    bool SDL_UpdateWindowSurface(SDL_Window *window);
    ```

### Complete SDL Example
Below is a full SDL program that creates a window, draws a gradient, and exits on ESC or window close:
```c
#include <stdio.h>
#include <SDL3/SDL.h>
int main() {
    // Initialize SDL
    if (!SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS)) {
        fprintf(stderr, "Error initializing SDL!\n");
        return -1;
    }
    // Create window
    SDL_Window *window = SDL_CreateWindow("Example", 800, 600, 0);
    if (window == NULL) {
        fprintf(stderr, "Error creating window!\n");
        SDL_Quit();
        return -1;
    }
    // Main loop
    int done = 0;
    while (!done) {
        // Handle events
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_EVENT_QUIT) {
                done = true;
            } else if (event.type == SDL_EVENT_KEY_UP) {
                if (event.key.key == SDLK_Q || event.key.key == SDLK_ESCAPE) {
                    done = true;
                }
            }
        }
        // Draw gradient
        SDL_Surface *surface = SDL_GetWindowSurface(window);
        SDL_LockSurface(surface);
        for (int y = 0; y < surface->h; y++) {
            for (int x = 0; x < surface->w; x++) {
                unsigned char *pixel = surface->pixels + y * surface->pitch + x * 4;
                float xf = (x + 0.5) / surface->w;
                float yf = (y + 0.5) / surface->h;
                pixel[0] = 0;                    // Blue
                pixel[1] = (unsigned char)(yf * 255); // Green
                pixel[2] = (unsigned char)(xf * 255); // Red
                pixel[3] = 255;                  // Alpha
            }
        }
        SDL_UnlockSurface(surface);
        SDL_UpdateWindowSurface(window);
        SDL_Delay(10); // Prevent high CPU usage
    }
    // Cleanup
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
```
- **Explanation**:
  - Initializes SDL for video and events.
  - Creates an 800x600 window.
  - Main loop:
    - Processes events (quit or ESC/Q key).
    - Draws a gradient where red varies with x, green with y.
    - Updates the display.
    - Adds a 10ms delay to reduce CPU load.
  - Cleans up by destroying the window and quitting SDL.

---

## Graphics Programming

### Limitations of Software Rendering
- The SDL example uses **software rendering** (CPU-based pixel manipulation).
- **Issue**: Inefficient for complex graphics due to high computational cost.
- **Solution**: Use **hardware rendering** with a GPU.

### Hardware Rendering with GPUs
- GPUs are optimized for parallel processing of graphics tasks.
- Common APIs for GPU programming:
  - **OpenGL**:
    - A specification for GPU interaction.
    - Supports uploading vertices, triangles, textures.
    - Uses **shader programs** to define rendering behavior.
  - **Vulkan**: A modern, low-level alternative to OpenGL.
- **Why GPUs?**
  - Handle large-scale rendering (e.g., 3D games).
  - Offload work from the CPU.

### OpenGL Basics
- **Key Concepts**:
  - **Vertices**: Points in 3D space.
  - **Triangles**: Basic shapes formed by vertices.
  - **Textures**: Images mapped onto surfaces.
  - **Shaders**: Programs running on the GPU to control rendering.
- **Learning Curve**:
  - Requires understanding GPU architecture and shader languages (e.g., GLSL).
  - More complex than SDL’s surface-based drawing.

### Instructor’s Note
- Graphics programming is a passion area!
- Students interested in graphics are encouraged to discuss further.

---

## Next Steps
- **Homework**:
  - Work on Homework 12 (mandatory).
  - Consider Homework 13 for extra credit.
- **Quiz**:
  - Complete Takehome Quiz #5 on Bernoulli distribution.
- **Preparation**:
  - Review SDL and random number concepts for the next lecture.

---

## Key Takeaways
1. **Random Numbers**:
   - Pseudo-random numbers (`random()`, `/dev/urandom`) are sufficient for most applications.
   - Use seeds for reproducibility or uniqueness.
   - Cryptographic applications require secure sources like `/dev/urandom`.
   - Uniform distributions can be transformed into others (e.g., Bernoulli).
2. **APIs**:
   - APIs simplify complex tasks by providing pre-built functionality.
   - SDL is a powerful API for graphics, input, and audio.
3. **Graphics**:
   - SDL enables basic graphics via surfaces but is CPU-limited.
   - GPU-based rendering (OpenGL, Vulkan) is essential for performance.
   - Graphics programming offers vast creative and technical opportunities.
